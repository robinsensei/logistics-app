BACKEND BUILD STEPS (NO CODE)
________________________________________
‚úÖ Step 1: Project Setup
1.	Create Spring Boot project using Spring Initializr or IntelliJ:
o	Dependencies: Spring Web, Spring Data JPA, Spring Security, Spring Boot DevTools, MySQL Driver or PostgreSQL, Lombok
2.	Setup application.yml:
o	Configure database
o	Configure JPA/Hibernate
o	Enable CORS if needed
________________________________________
‚úÖ Step 2: Define Project Structure
Organize packages like this:
css
CopyEdit
src/main/java/com/busfreeride/
‚îú‚îÄ‚îÄ config/
‚îú‚îÄ‚îÄ controller/
‚îú‚îÄ‚îÄ dto/
‚îú‚îÄ‚îÄ exception/
‚îú‚îÄ‚îÄ model/
‚îú‚îÄ‚îÄ repository/
‚îú‚îÄ‚îÄ service/
‚îú‚îÄ‚îÄ util/
‚îî‚îÄ‚îÄ security/
________________________________________
‚úÖ Step 3: Define Entity Models
Create model/ classes for:
‚Ä¢	User (with role)
‚Ä¢	Bus
‚Ä¢	Route
‚Ä¢	Schedule
‚Ä¢	RideLog
‚Ä¢	QRCode (optional separate or part of User)
Use JPA annotations to map these to DB tables.
________________________________________
‚úÖ Step 4: Implement Database Layer
In repository/, create interfaces:
‚Ä¢	UserRepository
‚Ä¢	BusRepository
‚Ä¢	RouteRepository
‚Ä¢	RideLogRepository
Use JpaRepository<> for CRUD operations.
________________________________________
‚úÖ Step 5: Set Up User Roles and Authentication
1.	Create Role enum: ROLE_CLIENT, ROLE_DRIVER, etc.
2.	Implement:
o	Spring Security Config (WebSecurityConfigurerAdapter or new approach)
o	JWT Token Generator & Validator (in security/)
o	UserDetailsService and AuthenticationManager
3.	Add role-based access control to endpoints.
________________________________________
‚úÖ Step 6: Implement Services (Business Logic)
In service/, create services:
‚Ä¢	AuthService: Register/login
‚Ä¢	UserService: CRUD + verification
‚Ä¢	BusService: Assign driver/conductor
‚Ä¢	RideService: QR scan log
‚Ä¢	ScheduleService: Handle route & time
________________________________________
‚úÖ Step 7: Expose REST API Controllers
In controller/, create endpoints grouped by purpose:
‚Ä¢	AuthController: /register, /login
‚Ä¢	UserController: /me, /verify
‚Ä¢	BusController: /buses, /assign
‚Ä¢	RideController: /ride/log
‚Ä¢	ScheduleController: /schedules, /routes
Use DTOs in dto/ for input/output handling.
________________________________________
‚úÖ Step 8: Add Utilities
In util/, implement:
‚Ä¢	QR Code Generator (ZXing or other lib)
‚Ä¢	Time/date helpers
‚Ä¢	File upload handler (if ID images are stored)
________________________________________
‚úÖ Step 9: Error Handling
In exception/, define:
‚Ä¢	Custom exceptions (e.g. UserNotFoundException)
‚Ä¢	GlobalExceptionHandler with @ControllerAdvice
________________________________________
‚úÖ Step 10: Testing & Documentation
‚Ä¢	Add Swagger/OpenAPI for documentation
‚Ä¢	Add unit tests for services
‚Ä¢	Add Postman collection for manual API testing





Step 1: Create Role enum
Use it in User to manage access levels
‚Ä¢	Define values: ROLE_ADMIN, ROLE_STAFF, ROLE_CLIENT, ROLE_DRIVER, ROLE_CONDUCTOR
________________________________________
‚úÖ Step 2: Create User entity
Central entity; all actors use it with different roles
‚Ä¢	Fields: id, name, email, password, role, contact_number, verified, etc.
‚Ä¢	Add optional fields:
o	employee_id (staff, driver, conductor)
o	license_number (driver)
o	id_type, id_number (client)
‚Ä¢	Relate to: QRCode, assignedBus (later)
________________________________________
‚úÖ Step 3: Create Bus entity
Represents each vehicle in the fleet
‚Ä¢	Fields: id, plate_number, capacity, status
‚Ä¢	Relations:
o	Assigned driver (User with ROLE_DRIVER)
o	Assigned conductor (User with ROLE_CONDUCTOR)
________________________________________
‚úÖ Step 4: Create Route entity
Logical group of stops, used for scheduling buses
‚Ä¢	Fields: id, route_name, start_point, end_point, stops, estimated_duration
________________________________________
‚úÖ Step 5: Create Schedule entity
Binds a Bus to a Route at a given time
‚Ä¢	Fields: id, bus, route, departure_time, arrival_time, date
‚Ä¢	May include recurrence (daily, weekends, etc.)
________________________________________
‚úÖ Step 6: Create QRCode entity (optional as separate)
Linked to clients; used for scanning
‚Ä¢	Fields: id, qr_value, user_id, generated_at, status
‚Ä¢	Optional: embed in User as string/byte array if simple
________________________________________
‚úÖ Step 7: Create RideLog entity
Tracks each ride for each passenger
‚Ä¢	Fields: id, user_id, bus_id, timestamp, location_boarded, verified_by (staff or conductor)
‚Ä¢	Useful for analytics, tracking and security



Start with Stop
Stops are the smallest unit ‚Äî individual bus stations or pickup/drop points

A Route is made up of multiple Stops

A Schedule refers to the route + its sequence of stops

2Ô∏è‚É£ Then Create Route
A Route defines the path the bus will take (e.g., "Quezon City to Pasay")

Has a list of ordered Stops

Includes name, estimated duration, total distance

3Ô∏è‚É£ Then Create Schedule
A Schedule binds a specific Bus to a specific Route at a specific Time

Includes departure_time, arrival_time, date

Links a Bus, Route, and optionally Driver/Conductor


üîç You're comparing two different tables:
Table	Represents
‚úÖ routes	The route itself (a defined path, like "Route 1 - Downtown Loop")
‚úÖ route_stops	The sequence of stops inside a specific route (e.g., Route 1 ‚Üí Stop A ‚Üí Stop B ‚Üí Stop C)


You are correct that you need a Route's ID to connect a stop to it, but the logic for creating
a Stop itself has not changed. The key is to distinguish between creating a Stop and linking a Stop to a Route.
http://localhost:8080/api/v1/routes/{route id}}/stops
POST /api/v1/routes/{routeId}/stops/batch-add
